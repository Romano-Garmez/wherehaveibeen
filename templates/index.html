{% extends "layout.html" %}

{%block title %}
<title>OwnTracks Map</title>
{%endblock%}

{% block main %}


<!-- Get OwnTracks server info so we can read data from it -->
<div>
    <div class="form-popup" id="myForm">
        <form action="/setcookie" method="POST">

            <h3>Enter OwnTrack Login and URL</h3>

            <input type='text' placeholder='username' name='username' />
            <input type='password' placeholder='password' name='password' />
            <input type='serverurl' placeholder='https://[your domain]' name='serverurl' /></p>
            <input class="btn" type='submit' value='Login' />
        </form>
    </div>

    <div id="map"></div>
</div>
<script>
    // todo: use these to handle move entries
    var qualityInverse = 3;
    var circleSize = 0.5;


    var control;
    // Initialize the map
    var map = L.map('map').setView([37.7749, -122.4194], 13);

    // Add a tile layer
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    async function getUsersAndDevices() {
        return fetch('/usersdevices')
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Error fetching users and devices. Are you logged in?`);
                }
                return response.json();  // Parse the JSON from the response
            })
            .then(data => {


                // Iterate through the data and populate the sets
                var select = document.getElementById("userBox");
                select.innerHTML = '';

                select = document.getElementById("deviceBox");
                select.innerHTML = '';

                var el;

                data.forEach(entry => {
                    if (entry.username) {
                        select = document.getElementById("userBox");

                        el = document.createElement("option");
                        el.textContent = entry.username;
                        el.value = entry.username;
                        select.appendChild(el);
                    }
                    if (entry.device) {
                        select = document.getElementById("deviceBox");

                        el = document.createElement("option");
                        el.textContent = entry.device;
                        el.value = entry.device;
                        select.appendChild(el);
                    }
                });

                return 0;

            })
            .catch(error => {
                console.error('Fetch users and devices error:', error);
                return -1;
            });

    }


    //handles all data retrieval and drawing on points/routes on map
    function fetchLocations() {
        let start = Date.now();

        fetch('/locations?' + new URLSearchParams({
            startdate: document.getElementById('startBox').value,
            enddate: document.getElementById('endBox').value,
            user: document.getElementById('userBox').value,
            device: document.getElementById('deviceBox').value
        }).toString())
            .then(response => {
                if (!response.ok) {
                    throw new Error('Error fetching location data+Are you logged in?');
                }
                return response.json();
            })
            .then(data => {
                // Successfully retrieved data, hide login prompt
                closeForm();

                if (data.features && Array.isArray(data.features)) {
                    // Create an array to hold the coordinates
                    var latlngs = [];

                    //console.log(data.features[0]);

                    var highestAltitude = 0;
                    var highestVelocity = 0;

                    data.features.forEach(feature => {
                        if (feature.geometry && feature.geometry.coordinates) {
                            const [lng, lat] = feature.geometry.coordinates;
                            // Add coordinates to the array

                            //markers with velocity of zero tend to be very inaccurate, skip them
                            if (feature.properties.vel > 0) {
                                latlngs.push([lat, lng]);

                                if (feature.properties.alt > highestAltitude) {
                                    highestAltitude = feature.properties.alt;
                                }
                                if (feature.properties.vel > highestVelocity) {
                                    highestVelocity = feature.properties.vel;
                                }


                                // Add marker to the map (recommended only for small datasets, quite laggy)
                                // L.marker([lat, lng]).addTo(map)
                                //     .bindPopup(`<b>${feature.properties.name}</b><br>Velocity: ${feature.properties.vel} km/h`);
                            }

                        }
                    });

                    getOwntracksStats(data.features, highestAltitude, highestVelocity);

                    // Get selected buffering method
                    var bufferingMethod = document.getElementById('bufferMethod').value;

                    let timeTaken = Date.now() - start;
                    console.log("Fetching locations time taken : " + timeTaken + " milliseconds");

                    if (latlngs.length > 1) {
                        if (bufferingMethod === 'complexRoute') {
                            bufferComplexRoute(latlngs);
                        } else if (bufferingMethod === 'simpleRoute') {
                            bufferSimpleRoute(latlngs);
                        }
                    }
                } else {
                    console.error('Unexpected data format:', data);
                }
            })
            .catch(error => {
                console.error('Fetch location error:', error);
            });
    }

    function bufferComplexRoute(latlngs) {
        let start = Date.now();

        drawRoute(latlngs);
        control.hide(); // hide top right panel

        // Listen for the routesfound event
        control.on('routesfound', function (e) {
            var routes = e.routes;

            // Create a lineString for buffering based on the actual route
            var routeCoords = routes[0].coordinates.map(coord => [coord.lng, coord.lat]);
            var lineString = turf.lineString(routeCoords);

            var bufferLayer = drawBuffer(lineString)

            // Adjust the view to show the entire buffered area
            var bounds = bufferLayer.getBounds();
            map.fitBounds(bounds);
        });

        let timeTaken = Date.now() - start;
        console.log("Complex route time taken : " + timeTaken + " milliseconds");

    }

    function bufferSimpleRoute(latlngs) {
        let start = Date.now();


        // Create a lineString for buffering
        var lineString = turf.lineString(latlngs.map(latlng => [latlng[1], latlng[0]])); // [lng, lat]

        drawBuffer(lineString)

        // Adjust the view to show all markers, circles, and the polyline
        var bounds = L.latLngBounds(latlngs);
        map.fitBounds(bounds);

        let timeTaken = Date.now() - start;
        console.log("Simple route time taken : " + timeTaken + " milliseconds");
    }


    function drawRoute(latlngs) {
        let start = Date.now();

        control = L.routing.control({
            waypoints: latlngs
                .filter((_, index) => index % qualityInverse === 0) // Filter to include only every other entry
                .map(latlng => L.latLng(latlng[0], latlng[1])),
            router: L.Routing.osrmv1({ serviceUrl: '/proxy' }),
            routeWhileDragging: false,
            createMarker: function () { return null; }, // Disable default marker
        }).addTo(map);

        let timeTaken = Date.now() - start;
        console.log("Draw route time taken : " + timeTaken + " milliseconds");
    }

    function drawBuffer(lineString) {
        let start = Date.now();

        // Simplify the route before buffering
        var simplifiedLineString = turf.simplify(lineString, { tolerance: .01, highQuality: false });

        // Buffer the route with Turf.js
        var buffered = turf.buffer(simplifiedLineString, circleSize, { units: 'kilometers', steps: 3 }); // 1 km buffer


        getCoverageStats(buffered, simplifiedLineString);


        // Convert the buffer to GeoJSON and add it to the map
        var bufferLayer = L.geoJSON(buffered, {
            style: function () {
                return { color: 'rgba(0, 0, 255, 0.4)', weight: 2 };
            }
        }).addTo(map);

        let timeTaken = Date.now() - start;
        console.log("Buffer drawing time taken : " + timeTaken + " milliseconds");

        return bufferLayer;
    }

    function getCoverageStats(buffered, lineString) {
        let start = Date.now();

        // Convert distance to kilometers
        var distanceKm = turf.length(lineString, { units: 'kilometers' }); // Total distance in kilometers

        document.getElementById('totalDist').innerHTML = "<p>" + Math.round(distanceKm * 100) / 100 + "km or " + Math.round((distanceKm / 1.609) * 100) / 100 + "mi</p>";

        // Calculate the total area of the route
        var area = turf.area(buffered) / 1e6; // Convert m² to km²

        document.getElementById('totalArea').innerHTML = "<p>" + Math.round(area * 100) / 100 + "km² or " + Math.round((area / 1.609) * 100) / 100 + "mi²</p>";

        document.getElementById('totalAreaPct').innerHTML = "<p>" + area / 863440 + "%" + "</p>";

        let timeTaken = Date.now() - start;
        console.log("Coverage stats time taken : " + timeTaken + " milliseconds");
    }

    function getOwntracksStats(datafeatures, highestAltitude, highestVelocity) {
        //start date
        console.log("Start date of OwnTracks data is " + datafeatures[0].properties.isotst.substring(0, 10));

        //total gps points
        console.log("Total number of OwnTracks data points is " + datafeatures.length);

        //highest altitude
        document.getElementById('highestAltitude').innerHTML = "<p>" + highestAltitude + "m or " + Math.round((highestAltitude * 3.281) * 100) / 100 + "ft</p>";

        //highest velocity
        document.getElementById('highestVelocity').innerHTML = "<p>" + highestVelocity + "kmh or " + Math.round((highestVelocity / 1.609) * 100) / 100 + "mph</p>";
    }



</script>

<div id="infoBox">
    <div id="leftPanel">
        <!-- MAP INFO -->
        <h1 id="title">Information </h1>
        <p> This map shows the location history of the devices that are sending their location data to the Owntracks server. Learn more on the about page.
        </p>

        <h4>Total distance driven </h4>
        <div id="totalDist"></div>

        <h4>Area explored is </h4>
        <div id="totalArea"></div>

        <h4>Percentage of west coast covered </h4>
        <div id="totalAreaPct"></div>

        <h4>Highest Altitude</h4>
        <div id="highestAltitude"></div>

        <h4>Highest Velocity</h4>
        <div id="highestVelocity"></div>
    </div>
    <div id="rightPanel">
        <!-- MAP CONTROLS -->
        <h1> Filters and Settings </h1>
        <p class="settingInfo">Is your data showing incorrectly on the map? Try adjusting these settings. Make sure the
            user and device are correct, and try changing the route computation method or time frame if it's too much
            data.</p>

        <h4>Choose a user and device</h4>
        <p class="settingInfo">Choose which device to track. This is your OwnTracks user and device.</p>


        <select id="userBox">
            <option value="" selected disabled>Choose a user</option>
        </select>
        <select id="deviceBox">
            <option value="" selected disabled>Choose a device</option>
        </select>
        <input type="submit" onsubmit="filterMap()" style="display: none" />
        <br>

        <h4>Choose a route computation method</h4>
        <p class="settingInfo">Choosing the "Complex Route" computation method tends to be more accurate, but slower to
            calculate and can fail on large datasets. The "Simple Route" computation method should work in almost all
            scenarios.</p>
        <select id="bufferMethod">
            <option value="complexRoute">Complex Route Buffer</option>
            <option value="simpleRoute">Simple Route Buffer</option>
        </select>

        <br>

        <h4>Map settings</h4>
        <p class="settingInfo">Hide the red route drawn on the map. The route is only drawn when using the "Complex
            Route" computation setting.</p>

        <input type="button" value="Remove Route" onclick="eraseRoute()" />

        <br>

        <h4>Time frame</h4>
        <p class="settingInfo">Filter the map to only shows GPS data between these two dates.</p>
        <div style="float:left; width: 50%;">
            <h5>Start Date </h5>

            <input type="date" id="startBox" onkeyup="" name="trip-start" value="2015-01-01" min="2015-01-01"
                max="2099-12-31" />
        </div>
        <div style="float:left; width: 50%;">
            <h5>End Date </h5>
            <input type="date" id="endBox" onkeyup="" name="trip-start" value="2099-12-31" min="2015-01-01"
                max="2099-12-31" />
        </div>
        <br>

        <h4>Save settings</h4>
        <input type="button" value="Save and Apply" onclick="filterMap()" />
    </div>
</div>


{% endblock %}

{% block scripts %}
<script>
    function filterMap() {
        console.log("Filtering map");

        try {
            eraseRoute();
            eraseLayers();
        }
        catch (err) {
            console.log("No map data to erase");
        }


        //Remake route
        // Add a tile layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        fetchLocations();
    }

    function eraseRoute() {
        map.removeControl(control);
    }

    function eraseLayers() {
        map.eachLayer((layer) => {
            layer.remove();
        });
    }

</script>

<script>

    function openForm() {
        document.getElementById("myForm").style.display = "block";
        document.getElementById("sign_out").style.display = "none"
    }
    function closeForm() {
        document.getElementById("myForm").style.display = "none";
        document.getElementById("sign_out").style.display = "block";
    }


    //find users and devices, then calculate route for the first entry
    getUsersAndDevices().then(usersAndDevices => {

        // if no users, not logged in
        if (usersAndDevices != -1) {
            fetchLocations();
        }

    });


</script>

{% endblock %}