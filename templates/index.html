{% extends "layout.html" %}

{%block title %}
<title>WhereHaveIBeen Map</title>
{%endblock%}

{% block main %}


<!-- Get OwnTracks server info so we can read data from it -->
<div id="map-container">
    <div class="form-popup" id="myForm">
        <form action="/login" method="POST">

            <h3>Enter OwnTrack Login and URL</h3>

            <input type='text' placeholder='username' name='username' autocomplete="on" />
            <input type='password' placeholder='password' name='password' autocomplete="on" />
            <input type='serverurl' placeholder='https://[your domain]' name='serverurl' autocomplete="on" /></p>
            <input class="btn btn-success" type='submit' value='Login' />
        </form>
    </div>

    <div id="map"></div>



    <div id="map-shadow"></div>
</div>
<script>
    //debuggingTest();

    // todo: use these to handle move entries
    var qualityInverse = 3;
    var circleSize = 0.5;


    var control;
    var latlngs;
    // Initialize the map
    var map = L.map('map').setView([37.7749, -122.4194], 13);

    // Add a tile layer
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    async function runTasks() {
        setProgressBarNumSteps(6);
        // find users and devices, then calculate route for the first entry

        const usersAndDevices = await getUsersAndDevices();

        if (usersAndDevices != -1) {
            //locations
            const data = await fetchLocations();
            updateProgressBar();

            //filter data
            const latlngs = await filterData(data)
            updateProgressBar();

            //get owntracks stats
            getOwntracksStats(data);

            //drawing buffer
            if (latlngs.length > 1) {
                let linestring;

                if (data.features.length < 500) {
                    linestring = await bufferComplexRoute(latlngs);
                } else {
                    linestring = await bufferSimpleRoute(latlngs);
                }
                updateProgressBar();

                const buffered = await drawBuffer(linestring, 0.01);
                updateProgressBar();

                //get stats
                getCoverageStats(buffered, linestring);
                updateProgressBar();

            }
        }
    }

    /**
     * Fetch the users and devices from the server. This function is called after get user and device data succeeds. It attempts to pull the GPS data from the OwnTracks server and calls other methods to draw and handle extra details.
     */
    async function fetchLocations() {
        let start = Date.now();

        try {
            // Build the query parameters
            const queryParams = new URLSearchParams({
                startdate: document.getElementById('startBox').value,
                enddate: document.getElementById('endBox').value,
                user: document.getElementById('userBox').value,
                device: document.getElementById('deviceBox').value
            }).toString();

            // Make the fetch request
            const response = await fetch(`/locations?${queryParams}`);

            // Check if response is not OK
            if (!response.ok) {
                setProgressBarError();  // Update progress bar with error state
                throw new Error('Error fetching location data. Are you logged in?');
            }

            // Parse the response JSON
            const data = await response.json();

            // Successfully retrieved data, hide login prompt
            closeForm();

            //start date
            console.log("Start date of OwnTracks data is " + data.features[0].properties.isotst.substring(0, 10));

            //set start date filter to the first date in the data
            document.getElementById('startBox').value = data.features[0].properties.isotst.substring(0, 10);
            document.getElementById('endBox').value = new Date().toLocaleDateString('en-CA');

            //total gps points
            console.log("Total number of OwnTracks data points is " + data.features.length);


            let timeTaken = Date.now() - start;
            completeTask("fetching locations", timeTaken);

            // Return the fetched data
            return data;
        } catch (error) {
            setProgressBarError();  // Update progress bar with error state
            console.error('Fetch location error:', error);
        }
    }

    /**
     * Draw the route on the map and buffer it using the simple route method. The simple route method uses Turf.js to buffer the route without calculating the route.
     * @param {Object} data - The data to filter
     * @returns {Array} - The filtered data
     */
    async function bufferSimpleRoute(latlngs) {
        let start = Date.now();

        await new Promise(resolve => setTimeout(resolve, 0)); // Allow UI to update

        // Split processing into smaller chunks
        let processedLatlngs = [];
        for (let i = 0; i < latlngs.length; i++) {
            processedLatlngs.push([latlngs[i][1], latlngs[i][0]]); // [lng, lat]

            // Every 100 iterations, yield control back to the browser to allow the UI to update
            if (i % 100 === 0) {
                await new Promise(resolve => setTimeout(resolve, 0));
            }
        }


        let lineString = turf.lineString(processedLatlngs);

        let timeTaken = Date.now() - start;
        completeTask("simple route drawing", timeTaken);

        return lineString;
    }

    /**
     * Draw the route on the map using Leaflet Routing Machine.
     * @param {Array} latlngs - The gps points to draw the route with
     */
    async function bufferComplexRoute(latlngs) {
        let start = Date.now();

        return new Promise((resolve, reject) => {
            let control = L.routing.control({
                waypoints: latlngs
                    .map(function (latlng) {
                        return L.latLng(latlng[0], latlng[1]);
                    }),
                router: L.Routing.osrmv1({
                    serviceUrl: '/proxy',
                    profile: 'car', // or 'bike', 'foot' depending on your needs
                }),
                routeWhileDragging: true,
                createMarker: function () { return null; }, // Disable default marker
            }).addTo(map);

            control.hide(); // hide top right panel

            control.on('routesfound', function (e) {
                let routes = e.routes;

                // Create a lineString for buffering based on the actual route
                let routeCoords = routes[0].coordinates.map(coord => [coord.lng, coord.lat]);
                let lineString = turf.lineString(routeCoords);

                let timeTaken = Date.now() - start;
                completeTask("complex route drawing", timeTaken);

                // Resolve the promise with the lineString
                resolve(lineString);
            });

            // Handle errors if needed
            control.on('routingerror', function (error) {
                reject(new Error("Routing failed: " + error.message));
            });
        });
    }

    /**
     * Draw a buffer around the route using Turf.js.
     * @param {Object} lineString - The lineString to buffer
     * @returns {Object} - The buffer layer
     */
    async function drawBuffer(lineString, tolerance) {
        let start = Date.now();

        // Wait before heavy computation to allow UI updates
        await new Promise(resolve => setTimeout(resolve, 0));

        // Get the circle size from the UI
        const circleSize = document.getElementById('circleSize').value;

        // Simplify the route in chunks to avoid freezing the UI
        let simplifiedLineString;
        await new Promise(resolve => setTimeout(() => {
            simplifiedLineString = turf.simplify(lineString, { tolerance: tolerance, highQuality: false });
            resolve();
        }, 0));

        // Add a short pause to ensure the UI updates before buffering
        await new Promise(resolve => setTimeout(resolve, 0));

        // Buffer the simplified route with Turf.js in chunks
        let buffered;
        await new Promise(resolve => setTimeout(() => {
            buffered = turf.buffer(simplifiedLineString, circleSize, { units: 'kilometers', steps: 3 }); // 1 km buffer
            resolve();
        }, 0));

        // Convert the buffer to GeoJSON and add it to the map
        let bufferLayer;
        await new Promise(resolve => setTimeout(() => {
            bufferLayer = L.geoJSON(buffered, {
                style: function () {
                    return { color: 'rgba(0, 0, 255, 0.4)', weight: 2 };
                }
            }).addTo(map);
            resolve();
        }, 0));

        let timeTaken = Date.now() - start;
        completeTask("buffer drawing", timeTaken);

        // Add a short pause to let the UI update before fitting the map bounds
        await new Promise(resolve => setTimeout(resolve, 0));

        // Adjust the map to fit the new buffer bounds
        const bounds = bufferLayer.getBounds();
        map.fitBounds(bounds);

        return buffered;
    }


    // run on page load
    window.onload = function () {

        // find users and devices, then calculate route for the first entry
        getUsersAndDevices().then(usersAndDevices => {

            // if no users, not logged in
            if (usersAndDevices != -1) {
                runTasks();
            }
        });
    };


</script>


<div id="progressBar">
    <div id="progressBarInner"></div>
</div>


<div id="infoBox">

    <div id="leftPanel">
        <!-- MAP CONTROLS -->

        <div class="innerPanel">
            <h1> Filters </h1>
            <p class="settingInfo">Is your data showing incorrectly on the map? Try adjusting these settings. Make sure
                the user and device are correct, and try changing time frame.</p>

            <h4>Choose a user and device</h4>
            <p class="settingInfo">Choose which device to track. This is your OwnTracks user and device.</p>


            <select class="form-select" id="userBox">
                <option value="" selected disabled>Choose a user</option>
            </select>
            <select class="form-select" id="deviceBox">
                <option value="" selected disabled>Choose a device</option>
            </select>
            <br>



            <h4>Time frame</h4>
            <p class="settingInfo">Filter the map to only shows GPS data between these two dates.</p>
            <div class="dateFilters" style="float:left; width: 50%;">
                <h5>Start Date </h5>

                <input type="date" class="input-group date" id="startBox" onkeyup="" name="trip-start"
                    value="2015-01-01" min="2015-01-01" max="2099-12-31" />
            </div>
            <div class="dateFilters" style="float:left; width: 50%;">
                <h5>End Date </h5>
                <input type="date" class="input-group date" id="endBox" onkeyup="" name="trip-start" value="2099-12-31"
                    min="2015-01-01" max="2099-12-31" />
            </div>

            <h4>Save and Apply Settings</h4>
            <input type="button" class="btn btn-primary" value="Apply" onclick="filterMap(map)" />
        </div>

        <div class="innerPanel">
            <h1>Visual settings</h1>
            <p class="settingInfo">Hide the red route drawn on the map. The route is only drawn when less than 500 GPS
                points are used. Adjust the date filters to see this!</p>

            <input type="button" class="btn btn-danger" value="Remove Route" onclick="eraseRoute(map)" />

            <h5>Buffer Size </h5>
            <p class="settingInfo">Change how large of a buffer is drawn around your route in kilometers. Note that
                larger values take
                longer to draw. Default: 0.5km</p>
            <input type="number" class="form-control form-control-lg" id="circleSize" value="0.5" step="0.1" min="0.1"
                max="10" />

            <h4>Save and Apply Settings</h4>
            <input type="button" class="btn btn-primary" value="Apply" onclick="filterMap(map)" />
        </div>
    </div>
    <div id="rightPanel">
        <!-- MAP INFO -->
        <h1 id="title">Information </h1>
        <p> This map shows the location history of the devices that are sending their location data to the Owntracks
            server. <a href="/about">Learn more.</a>
        </p>


        <h4>Total distance driven </h4>
        <div id="totalDist"></div>

        <h4>Area explored is </h4>
        <div id="totalArea"></div>

        <h4>Percentage of west coast covered </h4>
        <div id="totalAreaPct"></div>

        <h4>Highest Altitude</h4>
        <div id="highestAltitude"></div>

        <h4>Highest Velocity</h4>
        <div id="highestVelocity"></div>
    </div>
</div>


{% endblock %}

{% block scripts %}

<script>


</script>

{% endblock %}